"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.routeRequest = routeRequest;
const routingConfigData_1 = require("./routingConfigData");
const callLLM_1 = require("./callLLM");
const errorHandling_1 = require("./errorHandling");
const constants_1 = require("./constants");
const constants_2 = require("./constants");
const routingLog_1 = require("./routingLog");
async function routeRequest({ history, prompt, provider, model, metadata, userId }) {
    const log = new routingLog_1.RoutingLog();
    const conditions = routingConfigData_1.routingConfig.conditions || [];
    if (provider) {
        model = model || constants_2.MODELS[provider][0];
        return await routeToSpecified({ history, prompt, provider, model, log });
    }
    if (conditions.length > 0 && metadata) {
        for (const cond of conditions) {
            if (cond.query(metadata)) { // fulfills condition, call load balance
                try {
                    log.conditionMatched(cond.name);
                    log.routedToLoadBalance();
                    const selectedModel = weightedPick(cond.loadBalance);
                    log.modelSelected(selectedModel.provider, selectedModel.model);
                    return await (0, callLLM_1.default)({
                        history,
                        prompt,
                        provider: selectedModel.provider,
                        model: selectedModel.model,
                        log,
                        userId
                    });
                }
                catch (error) {
                    return await handleRoutingError(error, history, prompt, log, cond);
                }
            }
        }
    }
    return await routeToDefault({ history, prompt, log });
}
async function handleRoutingError(error, history, prompt, log, condition) {
    const statusCode = (0, errorHandling_1.getErrorStatusCode)(error);
    log.routingError(error.message, statusCode);
    const fallbackStatuses = routingConfigData_1.routingConfig.fallbackOnStatus || constants_1.FALLBACK_STATUS_CODES;
    if (statusCode && fallbackStatuses.includes(statusCode)) {
        return await routeToFallback({ history, prompt, condition, log });
    }
    else {
        console.error('Error routing request:', error);
        throw error;
    }
}
async function routeToDefault({ history, prompt, condition, log, userId }) {
    try {
        const { provider, model } = routingConfigData_1.routingConfig.defaultModel;
        log.routedToDefault(provider, model);
        return await (0, callLLM_1.default)({ history, prompt, provider, model, log, userId });
    }
    catch (error) {
        return handleRoutingError(error, history, prompt, log, condition);
    }
}
async function routeToFallback({ history, prompt, condition, log, userId }) {
    const fallbackModel = condition?.fallbackModel || routingConfigData_1.routingConfig.fallbackModel;
    log.routedToFallback(fallbackModel.provider, fallbackModel.model);
    const result = await (0, callLLM_1.default)({
        history,
        prompt,
        provider: fallbackModel.provider,
        model: fallbackModel.model,
        log,
        userId
    });
    return result;
}
async function routeToSpecified({ history, prompt, provider, model, log, userId }) {
    try {
        log.routedToSpecified(provider, model);
        return await (0, callLLM_1.default)({ history, prompt, provider, model, log, userId });
    }
    catch (error) {
        return handleRoutingError(error, history, prompt, log);
    }
}
function weightedPick(choices) {
    if (!choices.length) {
        throw new Error('No choices provided for weighted selection');
    }
    const totalWeight = choices.reduce((acc, choice) => acc + choice.weight, 0);
    const randomWeight = Math.random() * totalWeight;
    let currentWeight = 0;
    for (const choice of choices) {
        currentWeight += choice.weight;
        if (randomWeight < currentWeight) {
            return choice;
        }
    }
    return choices[choices.length - 1];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVSZXF1ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGFtYmRhL3V0aWwvcm91dGVSZXF1ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBV0Esb0NBNENDO0FBdkRELDJEQUFtRDtBQUVuRCx1Q0FBZ0M7QUFFaEMsbURBQXFEO0FBQ3JELDJDQUFvRDtBQUNwRCwyQ0FBcUM7QUFDckMsNkNBQTBDO0FBSW5DLEtBQUssVUFBVSxZQUFZLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBa0M7SUFVckgsTUFBTSxHQUFHLEdBQUcsSUFBSSx1QkFBVSxFQUFFLENBQUM7SUFDN0IsTUFBTSxVQUFVLEdBQUcsaUNBQWEsQ0FBQyxVQUFVLElBQUksRUFBRSxDQUFDO0lBRWxELElBQUksUUFBUSxFQUFFLENBQUM7UUFDYixLQUFLLEdBQUcsS0FBSyxJQUFJLGtCQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsT0FBTyxNQUFNLGdCQUFnQixDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUE7SUFDMUUsQ0FBQztJQUVELElBQUksVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksUUFBUSxFQUFFLENBQUM7UUFDdEMsS0FBSyxNQUFNLElBQUksSUFBSSxVQUFVLEVBQUUsQ0FBQztZQUU5QixJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLHdDQUF3QztnQkFDbEUsSUFBSSxDQUFDO29CQUNILEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7b0JBQy9CLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO29CQUMxQixNQUFNLGFBQWEsR0FBRyxZQUFZLENBQUMsSUFB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QU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7SUFDSCxDQUFDO0lBRUQsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNyQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcm91dGluZ0NvbmZpZyB9IGZyb20gJy4vcm91dGluZ0NvbmZpZ0RhdGEnXG5pbXBvcnQgeyBDYWxsTExNQXJncywgV2VpZ2h0ZWRQcm92aWRlck1vZGVsLCBQcm92aWRlck1vZGVsLCBSb3V0ZVJlcXVlc3RBcmdzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgY2FsbExMTSBmcm9tICcuL2NhbGxMTE0nO1xuaW1wb3J0IHsgQ29tcGxldGlvblJlc3BvbnNlIH0gZnJvbSAndG9rZW4uanMnO1xuaW1wb3J0IHsgZ2V0RXJyb3JTdGF0dXNDb2RlIH0gZnJvbSAnLi9lcnJvckhhbmRsaW5nJztcbmltcG9ydCB7IEZBTExCQUNLX1NUQVRVU19DT0RFUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IE1PREVMUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IFJvdXRpbmdMb2cgfSBmcm9tICcuL3JvdXRpbmdMb2cnO1xuaW1wb3J0IHsgU3VwcG9ydGVkTExNcywgTW9kZWxGb3JQcm92aWRlciB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgUm91dGluZ0xvZyBhcyBSb3V0aW5nTG9nVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcm91dGVSZXF1ZXN0KHsgaGlzdG9yeSwgcHJvbXB0LCBwcm92aWRlciwgbW9kZWwsIG1ldGFkYXRhLCB1c2VySWQgfTogT21pdCA8Um91dGVSZXF1ZXN0QXJncywgJ2xvZyc+KTpcblByb21pc2U8eyAgICAgICBcbiAgdGV4dDogc3RyaW5nLCBcbiAgdXNhZ2U6IENvbXBsZXRpb25SZXNwb25zZVsndXNhZ2UnXSwgXG4gIHByb3ZpZGVyOiBTdXBwb3J0ZWRMTE1zLCBcbiAgbW9kZWw6IE1vZGVsRm9yUHJvdmlkZXI8U3VwcG9ydGVkTExNcz4sIFxuICBsb2c6IFJvdXRpbmdMb2dUeXBlLFxuICBzaW1wbGVDYWNoZUhpdD86IGJvb2xlYW4sXG4gIHNlbWFudGljQ2FjaGVIaXQ/OiBib29sZWFuIFxufT4ge1xuICAgIGNvbnN0IGxvZyA9IG5ldyBSb3V0aW5nTG9nKCk7XG4gICAgY29uc3QgY29uZGl0aW9ucyA9IHJvdXRpbmdDb25maWcuY29uZGl0aW9ucyB8fCBbXTtcblxuICAgIGlmIChwcm92aWRlcikge1xuICAgICAgbW9kZWwgPSBtb2RlbCB8fCBNT0RFTFNbcHJvdmlkZXJdWzBdO1xuICAgICAgcmV0dXJuIGF3YWl0IHJvdXRlVG9TcGVjaWZpZWQoeyBoaXN0b3J5LCBwcm9tcHQsIHByb3ZpZGVyLCBtb2RlbCwgbG9nIH0pXG4gICAgfVxuXG4gICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoID4gMCAmJiBtZXRhZGF0YSkge1xuICAgICAgZm9yIChjb25zdCBjb25kIG9mIGNvbmRpdGlvbnMpIHtcblxuICAgICAgICBpZiAoY29uZC5xdWVyeShtZXRhZGF0YSkpIHsgLy8gZnVsZmlsbHMgY29uZGl0aW9uLCBjYWxsIGxvYWQgYmFsYW5jZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2cuY29uZGl0aW9uTWF0Y2hlZChjb25kLm5hbWUpXG4gICAgICAgICAgICBsb2cucm91dGVkVG9Mb2FkQmFsYW5jZSgpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRNb2RlbCA9IHdlaWdodGVkUGljayhjb25kLmxvYWRCYWxhbmNlKTtcbiAgICAgICAgICAgIGxvZy5tb2RlbFNlbGVjdGVkKHNlbGVjdGVkTW9kZWwucHJvdmlkZXIsIHNlbGVjdGVkTW9kZWwubW9kZWwpXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgY2FsbExMTSh7IFxuICAgICAgICAgICAgICBoaXN0b3J5LCBcbiAgICAgICAgICAgICAgcHJvbXB0LCBcbiAgICAgICAgICAgICAgcHJvdmlkZXI6IHNlbGVjdGVkTW9kZWwucHJvdmlkZXIsIFxuICAgICAgICAgICAgICBtb2RlbDogc2VsZWN0ZWRNb2RlbC5tb2RlbCxcbiAgICAgICAgICAgICAgbG9nLFxuICAgICAgICAgICAgICB1c2VySWRcbiAgICAgICAgICAgIH0pXG4gIFxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlUm91dGluZ0Vycm9yKGVycm9yLCBoaXN0b3J5LCBwcm9tcHQsIGxvZywgY29uZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCByb3V0ZVRvRGVmYXVsdCh7IGhpc3RvcnksIHByb21wdCwgbG9nIH0pXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJvdXRpbmdFcnJvcihcbiAgZXJyb3I6IGFueSxcbiAgaGlzdG9yeTogUm91dGVSZXF1ZXN0QXJnc1snaGlzdG9yeSddLFxuICBwcm9tcHQ6IFJvdXRlUmVxdWVzdEFyZ3NbJ3Byb21wdCddLFxuICBsb2c6IFJvdXRpbmdMb2csXG4gIGNvbmRpdGlvbj86IFJvdXRlUmVxdWVzdEFyZ3NbJ2NvbmRpdGlvbiddLFxuKSB7XG4gIGNvbnN0IHN0YXR1c0NvZGUgPSBnZXRFcnJvclN0YXR1c0NvZGUoZXJyb3IpO1xuICBsb2cucm91dGluZ0Vycm9yKGVycm9yLm1lc3NhZ2UsIHN0YXR1c0NvZGUpO1xuXG4gIGNvbnN0IGZhbGxiYWNrU3RhdHVzZXMgPSByb3V0aW5nQ29uZmlnLmZhbGxiYWNrT25TdGF0dXMgfHwgRkFMTEJBQ0tfU1RBVFVTX0NPREVTO1xuICBpZiAoc3RhdHVzQ29kZSAmJiBmYWxsYmFja1N0YXR1c2VzLmluY2x1ZGVzKHN0YXR1c0NvZGUpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJvdXRlVG9GYWxsYmFjayh7IGhpc3RvcnksIHByb21wdCwgY29uZGl0aW9uLCBsb2cgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igcm91dGluZyByZXF1ZXN0OicsIGVycm9yKVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJvdXRlVG9EZWZhdWx0KHsgaGlzdG9yeSwgcHJvbXB0LCBjb25kaXRpb24sIGxvZywgdXNlcklkIH06IFJvdXRlUmVxdWVzdEFyZ3MpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IHByb3ZpZGVyLCBtb2RlbCB9ID0gcm91dGluZ0NvbmZpZy5kZWZhdWx0TW9kZWw7XG4gICAgbG9nLnJvdXRlZFRvRGVmYXVsdChwcm92aWRlciwgbW9kZWwpO1xuICAgIHJldHVybiBhd2FpdCBjYWxsTExNKHsgaGlzdG9yeSwgcHJvbXB0LCBwcm92aWRlciwgbW9kZWwsIGxvZywgdXNlcklkIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBoYW5kbGVSb3V0aW5nRXJyb3IoZXJyb3IsIGhpc3RvcnksIHByb21wdCwgbG9nLCBjb25kaXRpb24pO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJvdXRlVG9GYWxsYmFjayh7IGhpc3RvcnksIHByb21wdCwgY29uZGl0aW9uLCBsb2csIHVzZXJJZCB9OiBSb3V0ZVJlcXVlc3RBcmdzKSB7XG4gIGNvbnN0IGZhbGxiYWNrTW9kZWwgPSBjb25kaXRpb24/LmZhbGxiYWNrTW9kZWwgfHwgcm91dGluZ0NvbmZpZy5mYWxsYmFja01vZGVsO1xuICBsb2cucm91dGVkVG9GYWxsYmFjayhmYWxsYmFja01vZGVsLnByb3ZpZGVyLCBmYWxsYmFja01vZGVsLm1vZGVsKTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbExMTSh7IFxuICAgICAgaGlzdG9yeSwgXG4gICAgICBwcm9tcHQsIFxuICAgICAgcHJvdmlkZXI6IGZhbGxiYWNrTW9kZWwucHJvdmlkZXIsIFxuICAgICAgbW9kZWw6IGZhbGxiYWNrTW9kZWwubW9kZWwsXG4gICAgICBsb2csXG4gICAgICB1c2VySWRcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcm91dGVUb1NwZWNpZmllZCh7IGhpc3RvcnksIHByb21wdCwgcHJvdmlkZXIsIG1vZGVsLCBsb2csIHVzZXJJZCB9OiBDYWxsTExNQXJncykge1xuICB0cnkge1xuICAgIGxvZy5yb3V0ZWRUb1NwZWNpZmllZChwcm92aWRlciwgbW9kZWwpO1xuICAgIHJldHVybiBhd2FpdCBjYWxsTExNKHsgaGlzdG9yeSwgcHJvbXB0LCBwcm92aWRlciwgbW9kZWwsIGxvZywgdXNlcklkIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBoYW5kbGVSb3V0aW5nRXJyb3IoZXJyb3IsIGhpc3RvcnksIHByb21wdCwgbG9nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3ZWlnaHRlZFBpY2soY2hvaWNlczogV2VpZ2h0ZWRQcm92aWRlck1vZGVsW10pOiBQcm92aWRlck1vZGVsIHtcbiAgaWYgKCFjaG9pY2VzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY2hvaWNlcyBwcm92aWRlZCBmb3Igd2VpZ2h0ZWQgc2VsZWN0aW9uJyk7XG4gIH1cblxuICBjb25zdCB0b3RhbFdlaWdodCA9IGNob2ljZXMucmVkdWNlKChhY2MsIGNob2ljZSkgPT4gYWNjICsgY2hvaWNlLndlaWdodCwgMCk7XG4gIGNvbnN0IHJhbmRvbVdlaWdodCA9IE1hdGgucmFuZG9tKCkgKiB0b3RhbFdlaWdodDtcblxuICBsZXQgY3VycmVudFdlaWdodCA9IDA7XG4gIGZvciAoY29uc3QgY2hvaWNlIG9mIGNob2ljZXMpIHtcbiAgICBjdXJyZW50V2VpZ2h0ICs9IGNob2ljZS53ZWlnaHQ7XG4gICAgaWYgKHJhbmRvbVdlaWdodCA8IGN1cnJlbnRXZWlnaHQpIHtcbiAgICAgIHJldHVybiBjaG9pY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNob2ljZXNbY2hvaWNlcy5sZW5ndGggLSAxXTtcbn1cblxuIl19