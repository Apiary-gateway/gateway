"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.routeRequest = routeRequest;
const callLLM_1 = __importDefault(require("./callLLM"));
const errorHandling_1 = require("./errorHandling");
const constants_1 = require("./constants");
const constants_2 = require("./constants");
const routingLog_1 = require("./routingLog");
const retryWithBackoff_1 = require("./retryWithBackoff");
const getConfig_1 = require("./getConfig");
async function routeRequest({ history, prompt, provider, model, metadata, userId }) {
    const log = new routingLog_1.RoutingLog();
    const config = (0, getConfig_1.getConfig)();
    const conditions = config.routing.conditions || [];
    if (provider) {
        model = model || constants_2.MODELS[provider][0];
        return await routeToSpecified({ history, prompt, provider, model, log });
    }
    if (conditions.length > 0 && metadata) {
        for (const cond of conditions) {
            if (cond.query(metadata)) { // fulfills condition, call load balance
                try {
                    log.conditionMatched(cond.name);
                    log.routedToLoadBalance();
                    const { provider, model } = weightedPick(cond.loadBalance);
                    log.modelSelected(provider, model);
                    return await (0, retryWithBackoff_1.retryWithBackoff)(() => (0, callLLM_1.default)({ history, prompt, provider, model, log, userId }));
                }
                catch (error) {
                    return await handleRoutingError(error, history, prompt, log, cond);
                }
            }
        }
    }
    return await routeToDefault({ history, prompt, log });
}
async function handleRoutingError(error, history, prompt, log, condition) {
    const config = (0, getConfig_1.getConfig)();
    const statusCode = (0, errorHandling_1.getErrorStatusCode)(error);
    log.routingError(error.message, statusCode);
    const fallbackStatuses = config.routing.fallbackOnStatus || constants_1.FALLBACK_STATUS_CODES;
    if (statusCode && config.routing.enableFallbacks && fallbackStatuses.includes(statusCode)) {
        return await routeToFallback({ history, prompt, condition, log });
    }
    else {
        console.error('Error routing request:', error);
        throw error;
    }
}
async function routeToDefault({ history, prompt, condition, log, userId }) {
    try {
        const config = (0, getConfig_1.getConfig)();
        const { provider, model } = config.routing.defaultModel;
        log.routedToDefault(provider, model);
        return await (0, retryWithBackoff_1.retryWithBackoff)(() => (0, callLLM_1.default)({ history, prompt, provider, model, log, userId }));
    }
    catch (error) {
        return handleRoutingError(error, history, prompt, log, condition);
    }
}
async function routeToFallback({ history, prompt, condition, log, userId }) {
    const config = (0, getConfig_1.getConfig)();
    const { provider, model } = condition?.fallbackModel || config.routing.fallbackModel;
    log.routedToFallback(provider, model);
    return await (0, retryWithBackoff_1.retryWithBackoff)(() => (0, callLLM_1.default)({ history, prompt, provider, model, log, userId }));
}
async function routeToSpecified({ history, prompt, provider, model, log, userId }) {
    try {
        log.routedToSpecified(provider, model);
        return await (0, retryWithBackoff_1.retryWithBackoff)(() => (0, callLLM_1.default)({ history, prompt, provider, model, log, userId }));
    }
    catch (error) {
        return handleRoutingError(error, history, prompt, log);
    }
}
function weightedPick(choices) {
    if (!choices.length) {
        throw new Error('No choices provided for weighted selection');
    }
    const totalWeight = choices.reduce((acc, choice) => acc + choice.weight, 0);
    const randomWeight = Math.random() * totalWeight;
    let currentWeight = 0;
    for (const choice of choices) {
        currentWeight += choice.weight;
        if (randomWeight < currentWeight) {
            return choice;
        }
    }
    return choices[choices.length - 1];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVSZXF1ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGFtYmRhL3V0aWwvcm91dGVSZXF1ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBVUEsb0NBc0NDO0FBL0NELHdEQUFnQztBQUVoQyxtREFBcUQ7QUFDckQsMkNBQW9EO0FBQ3BELDJDQUFxQztBQUNyQyw2Q0FBMEM7QUFDMUMseURBQXNEO0FBQ3RELDJDQUF1QztBQUVoQyxLQUFLLFVBQVUsWUFBWSxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQWtDO0lBV3JILE1BQU0sR0FBRyxHQUFHLElBQUksdUJBQVUsRUFBRSxDQUFDO0lBQzdCLE1BQU0sTUFBTSxHQUFHLElBQUEscUJBQVMsR0FBRSxDQUFDO0lBQzNCLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztJQUVuRCxJQUFJLFFBQVEsRUFBRSxDQUFDO1FBQ2IsS0FBSyxHQUFHLEtBQUssSUFBSSxrQkFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLE9BQU8sTUFBTSxnQkFBZ0IsQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFBO0lBQzFFLENBQUM7SUFFRCxJQUFJLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLFFBQVEsRUFBRSxDQUFDO1FBQ3RDLEtBQUssTUFBTSxJQUFJLElBQUksVUFBVSxFQUFFLENBQUM7WUFFOUIsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyx3Q0FBd0M7Z0JBQ2xFLElBQUksQ0FBQztvQkFDSCxHQUFHLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO29C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QUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM1RSxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsV0FBVyxDQUFDO0lBRWpELElBQUksYUFBYSxHQUFHLENBQUMsQ0FBQztJQUN0QixLQUFLLE1BQU0sTUFBTSxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQzdCLGFBQWEsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQy9CLElBQUksWUFBWSxHQUFHLGFBQWEsRUFBRSxDQUFDO1lBQ2pDLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7SUFDSCxDQUFDO0lBRUQsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN2QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FsbExMTUFyZ3MsIFdlaWdodGVkUHJvdmlkZXJNb2RlbCwgUHJvdmlkZXJNb2RlbCwgUm91dGVSZXF1ZXN0QXJncywgU3VwcG9ydGVkTExNcywgTW9kZWxGb3JQcm92aWRlciwgUm91dGluZ0xvZyBhcyBSb3V0aW5nTG9nVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IGNhbGxMTE0gZnJvbSAnLi9jYWxsTExNJztcbmltcG9ydCB7IENvbXBsZXRpb25SZXNwb25zZSB9IGZyb20gJ3Rva2VuLmpzJztcbmltcG9ydCB7IGdldEVycm9yU3RhdHVzQ29kZSB9IGZyb20gJy4vZXJyb3JIYW5kbGluZyc7XG5pbXBvcnQgeyBGQUxMQkFDS19TVEFUVVNfQ09ERVMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBNT0RFTFMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBSb3V0aW5nTG9nIH0gZnJvbSAnLi9yb3V0aW5nTG9nJztcbmltcG9ydCB7IHJldHJ5V2l0aEJhY2tvZmYgfSBmcm9tICcuL3JldHJ5V2l0aEJhY2tvZmYnO1xuaW1wb3J0IHsgZ2V0Q29uZmlnIH0gZnJvbSAnLi9nZXRDb25maWcnXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByb3V0ZVJlcXVlc3QoeyBoaXN0b3J5LCBwcm9tcHQsIHByb3ZpZGVyLCBtb2RlbCwgbWV0YWRhdGEsIHVzZXJJZCB9OiBPbWl0IDxSb3V0ZVJlcXVlc3RBcmdzLCAnbG9nJz4pOlxuUHJvbWlzZTx7ICAgICAgIFxuICB0ZXh0OiBzdHJpbmcsIFxuICB1c2FnZTogQ29tcGxldGlvblJlc3BvbnNlWyd1c2FnZSddLCBcbiAgcHJvdmlkZXI6IFN1cHBvcnRlZExMTXMsIFxuICBtb2RlbDogTW9kZWxGb3JQcm92aWRlcjxTdXBwb3J0ZWRMTE1zPiwgXG4gIGxvZzogUm91dGluZ0xvZ1R5cGUsXG4gIHNpbXBsZUNhY2hlSGl0PzogYm9vbGVhbixcbiAgc2VtYW50aWNDYWNoZUhpdD86IGJvb2xlYW4gXG59PiB7XG5cbiAgICBjb25zdCBsb2cgPSBuZXcgUm91dGluZ0xvZygpO1xuICAgIGNvbnN0IGNvbmZpZyA9IGdldENvbmZpZygpO1xuICAgIGNvbnN0IGNvbmRpdGlvbnMgPSBjb25maWcucm91dGluZy5jb25kaXRpb25zIHx8IFtdO1xuXG4gICAgaWYgKHByb3ZpZGVyKSB7XG4gICAgICBtb2RlbCA9IG1vZGVsIHx8IE1PREVMU1twcm92aWRlcl1bMF07XG4gICAgICByZXR1cm4gYXdhaXQgcm91dGVUb1NwZWNpZmllZCh7IGhpc3RvcnksIHByb21wdCwgcHJvdmlkZXIsIG1vZGVsLCBsb2cgfSlcbiAgICB9XG5cbiAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGggPiAwICYmIG1ldGFkYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IGNvbmQgb2YgY29uZGl0aW9ucykge1xuXG4gICAgICAgIGlmIChjb25kLnF1ZXJ5KG1ldGFkYXRhKSkgeyAvLyBmdWxmaWxscyBjb25kaXRpb24sIGNhbGwgbG9hZCBiYWxhbmNlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvZy5jb25kaXRpb25NYXRjaGVkKGNvbmQubmFtZSlcbiAgICAgICAgICAgIGxvZy5yb3V0ZWRUb0xvYWRCYWxhbmNlKCk7XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyLCBtb2RlbCB9ID0gd2VpZ2h0ZWRQaWNrKGNvbmQubG9hZEJhbGFuY2UpO1xuICAgICAgICAgICAgbG9nLm1vZGVsU2VsZWN0ZWQocHJvdmlkZXIsIG1vZGVsKVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJldHJ5V2l0aEJhY2tvZmYoKCkgPT4gY2FsbExMTSh7IGhpc3RvcnksIHByb21wdCwgcHJvdmlkZXIsIG1vZGVsLCBsb2csIHVzZXJJZCB9KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVSb3V0aW5nRXJyb3IoZXJyb3IsIGhpc3RvcnksIHByb21wdCwgbG9nLCBjb25kKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHJvdXRlVG9EZWZhdWx0KHsgaGlzdG9yeSwgcHJvbXB0LCBsb2cgfSlcbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUm91dGluZ0Vycm9yKFxuICAgIGVycm9yOiBhbnksXG4gICAgaGlzdG9yeTogUm91dGVSZXF1ZXN0QXJnc1snaGlzdG9yeSddLFxuICAgIHByb21wdDogUm91dGVSZXF1ZXN0QXJnc1sncHJvbXB0J10sXG4gICAgbG9nOiBSb3V0aW5nTG9nLFxuICAgIGNvbmRpdGlvbj86IFJvdXRlUmVxdWVzdEFyZ3NbJ2NvbmRpdGlvbiddLFxuKSB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKCk7XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IGdldEVycm9yU3RhdHVzQ29kZShlcnJvcik7XG4gICAgbG9nLnJvdXRpbmdFcnJvcihlcnJvci5tZXNzYWdlLCBzdGF0dXNDb2RlKTtcblxuICAgIGNvbnN0IGZhbGxiYWNrU3RhdHVzZXMgPSBjb25maWcucm91dGluZy5mYWxsYmFja09uU3RhdHVzIHx8IEZBTExCQUNLX1NUQVRVU19DT0RFUztcbiAgICBpZiAoc3RhdHVzQ29kZSAmJiBjb25maWcucm91dGluZy5lbmFibGVGYWxsYmFja3MgJiYgZmFsbGJhY2tTdGF0dXNlcy5pbmNsdWRlcyhzdGF0dXNDb2RlKSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHJvdXRlVG9GYWxsYmFjayh7IGhpc3RvcnksIHByb21wdCwgY29uZGl0aW9uLCBsb2cgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJvdXRpbmcgcmVxdWVzdDonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcm91dGVUb0RlZmF1bHQoeyBoaXN0b3J5LCBwcm9tcHQsIGNvbmRpdGlvbiwgbG9nLCB1c2VySWQgfTogUm91dGVSZXF1ZXN0QXJncykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25maWcgPSBnZXRDb25maWcoKTtcbiAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIG1vZGVsIH0gPSBjb25maWcucm91dGluZy5kZWZhdWx0TW9kZWw7XG4gICAgICBsb2cucm91dGVkVG9EZWZhdWx0KHByb3ZpZGVyLCBtb2RlbCk7XG4gICAgICByZXR1cm4gYXdhaXQgcmV0cnlXaXRoQmFja29mZigoKSA9PiBjYWxsTExNKHsgaGlzdG9yeSwgcHJvbXB0LCBwcm92aWRlciwgbW9kZWwsIGxvZywgdXNlcklkIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGhhbmRsZVJvdXRpbmdFcnJvcihlcnJvciwgaGlzdG9yeSwgcHJvbXB0LCBsb2csIGNvbmRpdGlvbik7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByb3V0ZVRvRmFsbGJhY2soeyBoaXN0b3J5LCBwcm9tcHQsIGNvbmRpdGlvbiwgbG9nLCB1c2VySWQgfTogUm91dGVSZXF1ZXN0QXJncykge1xuICAgIGNvbnN0IGNvbmZpZyA9IGdldENvbmZpZygpO1xuICAgIGNvbnN0IHsgcHJvdmlkZXIsIG1vZGVsIH0gPSBjb25kaXRpb24/LmZhbGxiYWNrTW9kZWwgfHwgY29uZmlnLnJvdXRpbmcuZmFsbGJhY2tNb2RlbDtcbiAgICBsb2cucm91dGVkVG9GYWxsYmFjayhwcm92aWRlciwgbW9kZWwpO1xuICAgIHJldHVybiBhd2FpdCByZXRyeVdpdGhCYWNrb2ZmKCgpID0+IGNhbGxMTE0oeyBoaXN0b3J5LCBwcm9tcHQsIHByb3ZpZGVyLCBtb2RlbCwgbG9nLCB1c2VySWR9KSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJvdXRlVG9TcGVjaWZpZWQoeyBoaXN0b3J5LCBwcm9tcHQsIHByb3ZpZGVyLCBtb2RlbCwgbG9nLCB1c2VySWQgfTogQ2FsbExMTUFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgbG9nLnJvdXRlZFRvU3BlY2lmaWVkKHByb3ZpZGVyLCBtb2RlbCk7XG4gICAgICByZXR1cm4gYXdhaXQgcmV0cnlXaXRoQmFja29mZigoKSA9PiBjYWxsTExNKHsgaGlzdG9yeSwgcHJvbXB0LCBwcm92aWRlciwgbW9kZWwsIGxvZywgdXNlcklkIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGhhbmRsZVJvdXRpbmdFcnJvcihlcnJvciwgaGlzdG9yeSwgcHJvbXB0LCBsb2cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gd2VpZ2h0ZWRQaWNrKGNob2ljZXM6IFdlaWdodGVkUHJvdmlkZXJNb2RlbFtdKTogUHJvdmlkZXJNb2RlbCB7XG4gICAgaWYgKCFjaG9pY2VzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjaG9pY2VzIHByb3ZpZGVkIGZvciB3ZWlnaHRlZCBzZWxlY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCB0b3RhbFdlaWdodCA9IGNob2ljZXMucmVkdWNlKChhY2MsIGNob2ljZSkgPT4gYWNjICsgY2hvaWNlLndlaWdodCwgMCk7XG4gICAgY29uc3QgcmFuZG9tV2VpZ2h0ID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsV2VpZ2h0O1xuXG4gICAgbGV0IGN1cnJlbnRXZWlnaHQgPSAwO1xuICAgIGZvciAoY29uc3QgY2hvaWNlIG9mIGNob2ljZXMpIHtcbiAgICAgIGN1cnJlbnRXZWlnaHQgKz0gY2hvaWNlLndlaWdodDtcbiAgICAgIGlmIChyYW5kb21XZWlnaHQgPCBjdXJyZW50V2VpZ2h0KSB7XG4gICAgICAgIHJldHVybiBjaG9pY2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNob2ljZXNbY2hvaWNlcy5sZW5ndGggLSAxXTtcbn1cblxuIl19