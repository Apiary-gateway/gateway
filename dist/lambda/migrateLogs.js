"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const client_s3_1 = require("@aws-sdk/client-s3");
const parquets = __importStar(require("parquets"));
const path = __importStar(require("path"));
const os = __importStar(require("os"));
const promises_1 = require("fs/promises");
const uuid_1 = require("uuid");
const ddb = new client_dynamodb_1.DynamoDBClient({});
const s3 = new client_s3_1.S3Client({});
const TABLE_NAME = process.env.LOG_TABLE_NAME;
const BUCKET_NAME = process.env.LOG_BUCKET_NAME;
// Set cutoff to 5 minutes ago
const FIVE_MINUTES = 5 * 60 * 1000;
// Parquet schema matching your logs
const schema = new parquets.ParquetSchema({
    id: { type: 'UTF8' },
    timestamp: { type: 'INT64', originalType: 'TIMESTAMP_MILLIS' },
    latency: { type: 'INT64' },
    is_successful: { type: 'BOOLEAN' },
    success_reason: { type: 'UTF8', optional: true },
    error_reason: { type: 'UTF8', optional: true },
    model_routing_history: { type: 'UTF8' },
    user_id: { type: 'UTF8', optional: true },
    metadata: { type: 'UTF8', optional: true },
    thread_id: { type: 'UTF8', optional: true },
    provider: { type: 'UTF8', optional: true },
    model: { type: 'UTF8', optional: true },
    cost: { type: 'DOUBLE', optional: true },
    raw_request: { type: 'UTF8', optional: true },
    raw_response: { type: 'UTF8', optional: true },
    error_message: { type: 'UTF8', optional: true },
});
const handler = async () => {
    try {
        console.log('Starting migrateLogs handler...');
        // 1) Determine cutoff date (5 minutes ago)
        const cutoffDate = new Date(Date.now() - FIVE_MINUTES);
        console.log(`Cutoff date: ${cutoffDate.toISOString()}`);
        // 2) Scan for old logs
        const logs = await scanOldLogs(cutoffDate);
        if (!logs.length) {
            console.log('No logs to migrate.');
            return { message: 'No logs to migrate.' };
        }
        console.log(`Total items scanned from Dynamo: ${logs.length}`);
        // 3) Group logs by partition: is_successful, date, provider, model
        const partitioned = {};
        for (const item of logs) {
            // Print some debug info about the item key
            console.log('DEBUG: Dynamo item ->', JSON.stringify({
                PK: item.PK?.S,
                SK: item.SK?.S,
                id: item.id?.S,
                timestamp: item.timestamp?.S,
            }));
            const row = mapDynamoItemToStructuredLog(item);
            console.log('DEBUG: Converted row ->', JSON.stringify(row));
            const isoDate = new Date(row.timestamp).toISOString(); // e.g. "2025-04-06T12:34:56.789Z"
            const dateOnly = isoDate.split('T')[0]; // e.g. "2025-04-06"
            const is_successful = row.is_successful ? 'true' : 'false';
            const provider = row.provider || 'unknown';
            const model = row.model || 'unknown';
            const partitionKey = `${is_successful}::${dateOnly}::${provider}::${model}`;
            if (!partitioned[partitionKey]) {
                partitioned[partitionKey] = [];
            }
            partitioned[partitionKey].push(row);
        }
        // 4) Write one Parquet file per partition
        for (const [partitionKey, items] of Object.entries(partitioned)) {
            const [is_successful, dateOnly, provider, model] = partitionKey.split('::');
            console.log(`DEBUG: Partition ${partitionKey} has ${items.length} items.`);
            // Write a single Parquet file locally to /tmp
            const parquetFile = path.join(os.tmpdir(), `batched-${(0, uuid_1.v4)()}.parquet`);
            console.log(`DEBUG: Writing Parquet to temp file -> ${parquetFile}`);
            const writer = await parquets.ParquetWriter.openFile(schema, parquetFile);
            let rowCount = 0;
            for (const row of items) {
                await writer.appendRow(row);
                rowCount++;
            }
            await writer.close();
            console.log(`DEBUG: Finished writing ${rowCount} rows to Parquet file: ${parquetFile}`);
            // 5) Upload the parquet to S3
            const buffer = await (0, promises_1.readFile)(parquetFile);
            const key = `logs/parquet/is_successful=${is_successful}/date=${dateOnly}/provider=${provider}/model=${model}/batch-${(0, uuid_1.v4)()}.parquet`;
            console.log(`DEBUG: Uploading Parquet file to s3://${BUCKET_NAME}/${key}`);
            await s3.send(new client_s3_1.PutObjectCommand({
                Bucket: BUCKET_NAME,
                Key: key,
                Body: buffer,
                ContentType: 'application/octet-stream',
            }));
            console.log(`Uploaded partition ${partitionKey} to s3://${BUCKET_NAME}/${key}`);
            // Clean up local file
            await (0, promises_1.unlink)(parquetFile);
            console.log(`DEBUG: Deleted temp file -> ${parquetFile}`);
        }
        // 6) Batch-delete from DynamoDB
        console.log('DEBUG: Deleting items from DynamoDB...');
        await deleteItemsFromDDB(logs);
        console.log(`Successfully migrated and deleted ${logs.length} items.`);
        return {
            message: 'Migration complete',
            totalItems: logs.length,
            partitions: Object.keys(partitioned).length,
        };
    }
    catch (err) {
        console.error('ERROR in migrateLogs handler:', err);
        throw err; // Rethrow so Lambda sees the error
    }
};
exports.handler = handler;
/**
 * Helper: SCAN old logs from DynamoDB
 */
async function scanOldLogs(cutoffDate) {
    console.log('DEBUG: Starting scanOldLogs...');
    const items = [];
    let ExclusiveStartKey;
    do {
        console.log(`DEBUG: Scanning table ${TABLE_NAME}, with ExclusiveStartKey =`, JSON.stringify(ExclusiveStartKey));
        const result = await ddb.send(new client_dynamodb_1.ScanCommand({
            TableName: TABLE_NAME,
            FilterExpression: '#ts <= :cutoff',
            ExpressionAttributeNames: {
                '#ts': 'timestamp',
            },
            ExpressionAttributeValues: {
                ':cutoff': { S: cutoffDate.toISOString() },
            },
            ExclusiveStartKey,
        }));
        if (result.Items) {
            console.log(`DEBUG: Scan returned ${result.Items.length} items this page.`);
            items.push(...result.Items);
        }
        else {
            console.log('DEBUG: Scan returned 0 items this page.');
        }
        ExclusiveStartKey = result.LastEvaluatedKey;
    } while (ExclusiveStartKey);
    console.log(`DEBUG: Total items found after scan: ${items.length}`);
    return items;
}
/**
 * Helper: Convert raw Dynamo item -> typed log row for Parquet
 */
function mapDynamoItemToStructuredLog(item) {
    // Convert timestamp to epoch millis (number)
    const isoTimestamp = item.timestamp?.S; // e.g. "2025-04-06T12:34:56.789Z"
    const epochMillis = isoTimestamp
        ? new Date(isoTimestamp).getTime()
        : Date.now();
    // Default cost to 0 if missing or invalid
    let costVal = 0;
    if (item.cost && item.cost.N !== undefined) {
        const parsedCost = Number(item.cost.N);
        if (!Number.isNaN(parsedCost)) {
            costVal = parsedCost;
        }
    }
    // Convert latency to a normal number instead of BigInt
    let latencyNum = 0;
    if (item.latency && item.latency.N !== undefined) {
        const parsedLatency = parseInt(item.latency.N, 10);
        if (!Number.isNaN(parsedLatency)) {
            latencyNum = parsedLatency;
        }
    }
    return {
        id: item.id?.S || (0, uuid_1.v4)(),
        timestamp: epochMillis,
        latency: latencyNum, // a normal number now
        is_successful: item.is_successful?.BOOL || false,
        success_reason: item.success_reason?.S || null,
        error_reason: item.error_reason?.S || null,
        model_routing_history: item.model_routing_history?.S || '',
        user_id: item.user_id?.S || null,
        metadata: item.metadata?.S || null,
        thread_id: item.thread_id?.S || null,
        provider: item.provider?.S || null,
        model: item.model?.S || null,
        cost: costVal,
        raw_request: item.raw_request?.S || null,
        raw_response: item.raw_response?.S || null,
        error_message: item.error_message?.S || null,
    };
}
/**
 * Helper: Batch-delete items from DynamoDB (25 at a time)
 */
async function deleteItemsFromDDB(dynamoItems) {
    let totalDeleted = 0;
    for (let i = 0; i < dynamoItems.length; i += 25) {
        const batch = dynamoItems.slice(i, i + 25);
        console.log(`DEBUG: Deleting batch of ${batch.length} items from index [${i}:${i + 25}].`);
        await ddb.send(new client_dynamodb_1.BatchWriteItemCommand({
            RequestItems: {
                [TABLE_NAME]: batch.map((item) => ({
                    DeleteRequest: {
                        // The "PK" and "SK" fields must match your table's real primary key fields
                        Key: {
                            PK: item.PK,
                            SK: item.SK,
                        },
                    },
                })),
            },
        }));
        totalDeleted += batch.length;
    }
    console.log(`DEBUG: Finished deleting ${totalDeleted} items total.`);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWlncmF0ZUxvZ3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9sYW1iZGEvbWlncmF0ZUxvZ3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw4REFNa0M7QUFDbEMsa0RBQWdFO0FBQ2hFLG1EQUFxQztBQUNyQywyQ0FBNkI7QUFDN0IsdUNBQXlCO0FBQ3pCLDBDQUErQztBQUMvQywrQkFBb0M7QUFFcEMsTUFBTSxHQUFHLEdBQUcsSUFBSSxnQ0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ25DLE1BQU0sRUFBRSxHQUFHLElBQUksb0JBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUU1QixNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWUsQ0FBQztBQUMvQyxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWdCLENBQUM7QUFFakQsOEJBQThCO0FBQzlCLE1BQU0sWUFBWSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0FBRW5DLG9DQUFvQztBQUNwQyxNQUFNLE1BQU0sR0FBRyxJQUFJLFFBQVEsQ0FBQyxhQUFhLENBQUM7SUFDeEMsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRTtJQUNwQixTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxrQkFBa0IsRUFBUztJQUNyRSxPQUFPLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFO0lBQzFCLGFBQWEsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUU7SUFDbEMsY0FBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFO0lBQ2hELFlBQVksRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRTtJQUM5QyxxQkFBcUIsRUFBRSxFQUFFLElBQUks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QyxDQUFDO0FBQ3ZFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEeW5hbW9EQkNsaWVudCxcbiAgU2NhbkNvbW1hbmQsXG4gIEJhdGNoV3JpdGVJdGVtQ29tbWFuZCxcbiAgQXR0cmlidXRlVmFsdWUsXG4gIFNjYW5Db21tYW5kT3V0cHV0XG59IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1keW5hbW9kYic7XG5pbXBvcnQgeyBTM0NsaWVudCwgUHV0T2JqZWN0Q29tbWFuZCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1zMyc7XG5pbXBvcnQgKiBhcyBwYXJxdWV0cyBmcm9tICdwYXJxdWV0cyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IHsgcmVhZEZpbGUsIHVubGluayB9IGZyb20gJ2ZzL3Byb21pc2VzJztcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuXG5jb25zdCBkZGIgPSBuZXcgRHluYW1vREJDbGllbnQoe30pO1xuY29uc3QgczMgPSBuZXcgUzNDbGllbnQoe30pO1xuXG5jb25zdCBUQUJMRV9OQU1FID0gcHJvY2Vzcy5lbnYuTE9HX1RBQkxFX05BTUUhO1xuY29uc3QgQlVDS0VUX05BTUUgPSBwcm9jZXNzLmVudi5MT0dfQlVDS0VUX05BTUUhO1xuXG4vLyBTZXQgY3V0b2ZmIHRvIDUgbWludXRlcyBhZ29cbmNvbnN0IEZJVkVfTUlOVVRFUyA9IDUgKiA2MCAqIDEwMDA7XG5cbi8vIFBhcnF1ZXQgc2NoZW1hIG1hdGNoaW5nIHlvdXIgbG9nc1xuY29uc3Qgc2NoZW1hID0gbmV3IHBhcnF1ZXRzLlBhcnF1ZXRTY2hlbWEoe1xuICBpZDogeyB0eXBlOiAnVVRGOCcgfSxcbiAgdGltZXN0YW1wOiB7IHR5cGU6ICdJTlQ2NCcsIG9yaWdpbmFsVHlwZTogJ1RJTUVTVEFNUF9NSUxMSVMnIH0gYXMgYW55LFxuICBsYXRlbmN5OiB7IHR5cGU6ICdJTlQ2NCcgfSxcbiAgaXNfc3VjY2Vzc2Z1bDogeyB0eXBlOiAnQk9PTEVBTicgfSxcbiAgc3VjY2Vzc19yZWFzb246IHsgdHlwZTogJ1VURjgnLCBvcHRpb25hbDogdHJ1ZSB9LFxuICBlcnJvcl9yZWFzb246IHsgdHlwZTogJ1VURjgnLCBvcHRpb25hbDogdHJ1ZSB9LFxuICBtb2RlbF9yb3V0aW5nX2hpc3Rvcnk6IHsgdHlwZTogJ1VURjgnIH0sXG4gIHVzZXJfaWQ6IHsgdHlwZTogJ1VURjgnLCBvcHRpb25hbDogdHJ1ZSB9LFxuICBtZXRhZGF0YTogeyB0eXBlOiAnVVRGOCcsIG9wdGlvbmFsOiB0cnVlIH0sXG4gIHRocmVhZF9pZDogeyB0eXBlOiAnVVRGOCcsIG9wdGlvbmFsOiB0cnVlIH0sXG4gIHByb3ZpZGVyOiB7IHR5cGU6ICdVVEY4Jywgb3B0aW9uYWw6IHRydWUgfSxcbiAgbW9kZWw6IHsgdHlwZTogJ1VURjgnLCBvcHRpb25hbDogdHJ1ZSB9LFxuICBjb3N0OiB7IHR5cGU6ICdET1VCTEUnLCBvcHRpb25hbDogdHJ1ZSB9LFxuICByYXdfcmVxdWVzdDogeyB0eXBlOiAnVVRGOCcsIG9wdGlvbmFsOiB0cnVlIH0sXG4gIHJhd19yZXNwb25zZTogeyB0eXBlOiAnVVRGOCcsIG9wdGlvbmFsOiB0cnVlIH0sXG4gIGVycm9yX21lc3NhZ2U6IHsgdHlwZTogJ1VURjgnLCBvcHRpb25hbDogdHJ1ZSB9LFxufSk7XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVyID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBtaWdyYXRlTG9ncyBoYW5kbGVyLi4uJyk7XG5cbiAgICAvLyAxKSBEZXRlcm1pbmUgY3V0b2ZmIGRhdGUgKDUgbWludXRlcyBhZ28pXG4gICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBGSVZFX01JTlVURVMpO1xuICAgIGNvbnNvbGUubG9nKGBDdXRvZmYgZGF0ZTogJHtjdXRvZmZEYXRlLnRvSVNPU3RyaW5nKCl9YCk7XG5cbiAgICAvLyAyKSBTY2FuIGZvciBvbGQgbG9nc1xuICAgIGNvbnN0IGxvZ3MgPSBhd2FpdCBzY2FuT2xkTG9ncyhjdXRvZmZEYXRlKTtcblxuICAgIGlmICghbG9ncy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdObyBsb2dzIHRvIG1pZ3JhdGUuJyk7XG4gICAgICByZXR1cm4geyBtZXNzYWdlOiAnTm8gbG9ncyB0byBtaWdyYXRlLicgfTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgVG90YWwgaXRlbXMgc2Nhbm5lZCBmcm9tIER5bmFtbzogJHtsb2dzLmxlbmd0aH1gKTtcblxuICAgIC8vIDMpIEdyb3VwIGxvZ3MgYnkgcGFydGl0aW9uOiBpc19zdWNjZXNzZnVsLCBkYXRlLCBwcm92aWRlciwgbW9kZWxcbiAgICBjb25zdCBwYXJ0aXRpb25lZDogUmVjb3JkPHN0cmluZywgYW55W10+ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbG9ncykge1xuICAgICAgLy8gUHJpbnQgc29tZSBkZWJ1ZyBpbmZvIGFib3V0IHRoZSBpdGVtIGtleVxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICdERUJVRzogRHluYW1vIGl0ZW0gLT4nLFxuICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgUEs6IGl0ZW0uUEs/LlMsXG4gICAgICAgICAgU0s6IGl0ZW0uU0s/LlMsXG4gICAgICAgICAgaWQ6IGl0ZW0uaWQ/LlMsXG4gICAgICAgICAgdGltZXN0YW1wOiBpdGVtLnRpbWVzdGFtcD8uUyxcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJvdyA9IG1hcER5bmFtb0l0ZW1Ub1N0cnVjdHVyZWRMb2coaXRlbSk7XG4gICAgICBjb25zb2xlLmxvZygnREVCVUc6IENvbnZlcnRlZCByb3cgLT4nLCBKU09OLnN0cmluZ2lmeShyb3cpKTtcblxuICAgICAgY29uc3QgaXNvRGF0ZSA9IG5ldyBEYXRlKHJvdy50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCk7IC8vIGUuZy4gXCIyMDI1LTA0LTA2VDEyOjM0OjU2Ljc4OVpcIlxuICAgICAgY29uc3QgZGF0ZU9ubHkgPSBpc29EYXRlLnNwbGl0KCdUJylbMF07IC8vIGUuZy4gXCIyMDI1LTA0LTA2XCJcbiAgICAgIGNvbnN0IGlzX3N1Y2Nlc3NmdWwgPSByb3cuaXNfc3VjY2Vzc2Z1bCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICBjb25zdCBwcm92aWRlciA9IHJvdy5wcm92aWRlciB8fCAndW5rbm93bic7XG4gICAgICBjb25zdCBtb2RlbCA9IHJvdy5tb2RlbCB8fCAndW5rbm93bic7XG5cbiAgICAgIGNvbnN0IHBhcnRpdGlvbktleSA9IGAke2lzX3N1Y2Nlc3NmdWx9Ojoke2RhdGVPbmx5fTo6JHtwcm92aWRlcn06OiR7bW9kZWx9YDtcbiAgICAgIGlmICghcGFydGl0aW9uZWRbcGFydGl0aW9uS2V5XSkge1xuICAgICAgICBwYXJ0aXRpb25lZFtwYXJ0aXRpb25LZXldID0gW107XG4gICAgICB9XG4gICAgICBwYXJ0aXRpb25lZFtwYXJ0aXRpb25LZXldLnB1c2gocm93KTtcbiAgICB9XG5cbiAgICAvLyA0KSBXcml0ZSBvbmUgUGFycXVldCBmaWxlIHBlciBwYXJ0aXRpb25cbiAgICBmb3IgKGNvbnN0IFtwYXJ0aXRpb25LZXksIGl0ZW1zXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0aXRpb25lZCkpIHtcbiAgICAgIGNvbnN0IFtpc19zdWNjZXNzZnVsLCBkYXRlT25seSwgcHJvdmlkZXIsIG1vZGVsXSA9XG4gICAgICAgIHBhcnRpdGlvbktleS5zcGxpdCgnOjonKTtcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBERUJVRzogUGFydGl0aW9uICR7cGFydGl0aW9uS2V5fSBoYXMgJHtpdGVtcy5sZW5ndGh9IGl0ZW1zLmBcbiAgICAgICk7XG5cbiAgICAgIC8vIFdyaXRlIGEgc2luZ2xlIFBhcnF1ZXQgZmlsZSBsb2NhbGx5IHRvIC90bXBcbiAgICAgIGNvbnN0IHBhcnF1ZXRGaWxlID0gcGF0aC5qb2luKG9zLnRtcGRpcigpLCBgYmF0Y2hlZC0ke3V1aWR2NCgpfS5wYXJxdWV0YCk7XG4gICAgICBjb25zb2xlLmxvZyhgREVCVUc6IFdyaXRpbmcgUGFycXVldCB0byB0ZW1wIGZpbGUgLT4gJHtwYXJxdWV0RmlsZX1gKTtcblxuICAgICAgY29uc3Qgd3JpdGVyID0gYXdhaXQgcGFycXVldHMuUGFycXVldFdyaXRlci5vcGVuRmlsZShzY2hlbWEsIHBhcnF1ZXRGaWxlKTtcbiAgICAgIGxldCByb3dDb3VudCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiBpdGVtcykge1xuICAgICAgICBhd2FpdCB3cml0ZXIuYXBwZW5kUm93KHJvdyk7XG4gICAgICAgIHJvd0NvdW50Kys7XG4gICAgICB9XG4gICAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBERUJVRzogRmluaXNoZWQgd3JpdGluZyAke3Jvd0NvdW50fSByb3dzIHRvIFBhcnF1ZXQgZmlsZTogJHtwYXJxdWV0RmlsZX1gXG4gICAgICApO1xuXG4gICAgICAvLyA1KSBVcGxvYWQgdGhlIHBhcnF1ZXQgdG8gUzNcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlYWRGaWxlKHBhcnF1ZXRGaWxlKTtcbiAgICAgIGNvbnN0IGtleSA9IGBsb2dzL3BhcnF1ZXQvaXNfc3VjY2Vzc2Z1bD0ke2lzX3N1Y2Nlc3NmdWx9L2RhdGU9JHtkYXRlT25seX0vcHJvdmlkZXI9JHtwcm92aWRlcn0vbW9kZWw9JHttb2RlbH0vYmF0Y2gtJHt1dWlkdjQoKX0ucGFycXVldGA7XG5cbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgREVCVUc6IFVwbG9hZGluZyBQYXJxdWV0IGZpbGUgdG8gczM6Ly8ke0JVQ0tFVF9OQU1FfS8ke2tleX1gXG4gICAgICApO1xuICAgICAgYXdhaXQgczMuc2VuZChcbiAgICAgICAgbmV3IFB1dE9iamVjdENvbW1hbmQoe1xuICAgICAgICAgIEJ1Y2tldDogQlVDS0VUX05BTUUsXG4gICAgICAgICAgS2V5OiBrZXksXG4gICAgICAgICAgQm9keTogYnVmZmVyLFxuICAgICAgICAgIENvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgVXBsb2FkZWQgcGFydGl0aW9uICR7cGFydGl0aW9uS2V5fSB0byBzMzovLyR7QlVDS0VUX05BTUV9LyR7a2V5fWBcbiAgICAgICk7XG5cbiAgICAgIC8vIENsZWFuIHVwIGxvY2FsIGZpbGVcbiAgICAgIGF3YWl0IHVubGluayhwYXJxdWV0RmlsZSk7XG4gICAgICBjb25zb2xlLmxvZyhgREVCVUc6IERlbGV0ZWQgdGVtcCBmaWxlIC0+ICR7cGFycXVldEZpbGV9YCk7XG4gICAgfVxuXG4gICAgLy8gNikgQmF0Y2gtZGVsZXRlIGZyb20gRHluYW1vREJcbiAgICBjb25zb2xlLmxvZygnREVCVUc6IERlbGV0aW5nIGl0ZW1zIGZyb20gRHluYW1vREIuLi4nKTtcbiAgICBhd2FpdCBkZWxldGVJdGVtc0Zyb21EREIobG9ncyk7XG5cbiAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IG1pZ3JhdGVkIGFuZCBkZWxldGVkICR7bG9ncy5sZW5ndGh9IGl0ZW1zLmApO1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiAnTWlncmF0aW9uIGNvbXBsZXRlJyxcbiAgICAgIHRvdGFsSXRlbXM6IGxvZ3MubGVuZ3RoLFxuICAgICAgcGFydGl0aW9uczogT2JqZWN0LmtleXMocGFydGl0aW9uZWQpLmxlbmd0aCxcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFUlJPUiBpbiBtaWdyYXRlTG9ncyBoYW5kbGVyOicsIGVycik7XG4gICAgdGhyb3cgZXJyOyAvLyBSZXRocm93IHNvIExhbWJkYSBzZWVzIHRoZSBlcnJvclxuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlcjogU0NBTiBvbGQgbG9ncyBmcm9tIER5bmFtb0RCXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNjYW5PbGRMb2dzKGN1dG9mZkRhdGU6IERhdGUpOiBQcm9taXNlPGFueVtdPiB7XG4gIGNvbnNvbGUubG9nKCdERUJVRzogU3RhcnRpbmcgc2Nhbk9sZExvZ3MuLi4nKTtcblxuICBjb25zdCBpdGVtczogYW55W10gPSBbXTtcbiAgbGV0IEV4Y2x1c2l2ZVN0YXJ0S2V5O1xuXG4gIGRvIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGBERUJVRzogU2Nhbm5pbmcgdGFibGUgJHtUQUJMRV9OQU1FfSwgd2l0aCBFeGNsdXNpdmVTdGFydEtleSA9YCxcbiAgICAgIEpTT04uc3RyaW5naWZ5KEV4Y2x1c2l2ZVN0YXJ0S2V5KVxuICAgICk7XG5cbiAgICBjb25zdCByZXN1bHQ6IFNjYW5Db21tYW5kT3V0cHV0ID0gYXdhaXQgZGRiLnNlbmQoXG4gICAgICBuZXcgU2NhbkNvbW1hbmQoe1xuICAgICAgICBUYWJsZU5hbWU6IFRBQkxFX05BTUUsXG4gICAgICAgIEZpbHRlckV4cHJlc3Npb246ICcjdHMgPD0gOmN1dG9mZicsXG4gICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lczoge1xuICAgICAgICAgICcjdHMnOiAndGltZXN0YW1wJyxcbiAgICAgICAgfSxcbiAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgICAgICAgICc6Y3V0b2ZmJzogeyBTOiBjdXRvZmZEYXRlLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgICAgfSxcbiAgICAgICAgRXhjbHVzaXZlU3RhcnRLZXksXG4gICAgICB9KVxuICAgICk7XG5cbiAgICBpZiAocmVzdWx0Lkl0ZW1zKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYERFQlVHOiBTY2FuIHJldHVybmVkICR7cmVzdWx0Lkl0ZW1zLmxlbmd0aH0gaXRlbXMgdGhpcyBwYWdlLmBcbiAgICAgICk7XG4gICAgICBpdGVtcy5wdXNoKC4uLnJlc3VsdC5JdGVtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdERUJVRzogU2NhbiByZXR1cm5lZCAwIGl0ZW1zIHRoaXMgcGFnZS4nKTtcbiAgICB9XG5cbiAgICBFeGNsdXNpdmVTdGFydEtleSA9IHJlc3VsdC5MYXN0RXZhbHVhdGVkS2V5O1xuICB9IHdoaWxlIChFeGNsdXNpdmVTdGFydEtleSk7XG5cbiAgY29uc29sZS5sb2coYERFQlVHOiBUb3RhbCBpdGVtcyBmb3VuZCBhZnRlciBzY2FuOiAke2l0ZW1zLmxlbmd0aH1gKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlcjogQ29udmVydCByYXcgRHluYW1vIGl0ZW0gLT4gdHlwZWQgbG9nIHJvdyBmb3IgUGFycXVldFxuICovXG5mdW5jdGlvbiBtYXBEeW5hbW9JdGVtVG9TdHJ1Y3R1cmVkTG9nKGl0ZW06IFJlY29yZDxzdHJpbmcsIEF0dHJpYnV0ZVZhbHVlPikge1xuICAvLyBDb252ZXJ0IHRpbWVzdGFtcCB0byBlcG9jaCBtaWxsaXMgKG51bWJlcilcbiAgY29uc3QgaXNvVGltZXN0YW1wID0gaXRlbS50aW1lc3RhbXA/LlM7IC8vIGUuZy4gXCIyMDI1LTA0LTA2VDEyOjM0OjU2Ljc4OVpcIlxuICBjb25zdCBlcG9jaE1pbGxpcyA9IGlzb1RpbWVzdGFtcFxuICAgID8gbmV3IERhdGUoaXNvVGltZXN0YW1wKS5nZXRUaW1lKClcbiAgICA6IERhdGUubm93KCk7XG5cbiAgLy8gRGVmYXVsdCBjb3N0IHRvIDAgaWYgbWlzc2luZyBvciBpbnZhbGlkXG4gIGxldCBjb3N0VmFsID0gMDtcbiAgaWYgKGl0ZW0uY29zdCAmJiBpdGVtLmNvc3QuTiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcGFyc2VkQ29zdCA9IE51bWJlcihpdGVtLmNvc3QuTik7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFyc2VkQ29zdCkpIHtcbiAgICAgIGNvc3RWYWwgPSBwYXJzZWRDb3N0O1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbnZlcnQgbGF0ZW5jeSB0byBhIG5vcm1hbCBudW1iZXIgaW5zdGVhZCBvZiBCaWdJbnRcbiAgbGV0IGxhdGVuY3lOdW0gPSAwO1xuICBpZiAoaXRlbS5sYXRlbmN5ICYmIGl0ZW0ubGF0ZW5jeS5OICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBwYXJzZWRMYXRlbmN5ID0gcGFyc2VJbnQoaXRlbS5sYXRlbmN5Lk4sIDEwKTtcbiAgICBpZiAoIU51bWJlci5pc05hTihwYXJzZWRMYXRlbmN5KSkge1xuICAgICAgbGF0ZW5jeU51bSA9IHBhcnNlZExhdGVuY3k7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogaXRlbS5pZD8uUyB8fCB1dWlkdjQoKSxcbiAgICB0aW1lc3RhbXA6IGVwb2NoTWlsbGlzLFxuICAgIGxhdGVuY3k6IGxhdGVuY3lOdW0sIC8vIGEgbm9ybWFsIG51bWJlciBub3dcbiAgICBpc19zdWNjZXNzZnVsOiBpdGVtLmlzX3N1Y2Nlc3NmdWw/LkJPT0wgfHwgZmFsc2UsXG4gICAgc3VjY2Vzc19yZWFzb246IGl0ZW0uc3VjY2Vzc19yZWFzb24/LlMgfHwgbnVsbCxcbiAgICBlcnJvcl9yZWFzb246IGl0ZW0uZXJyb3JfcmVhc29uPy5TIHx8IG51bGwsXG4gICAgbW9kZWxfcm91dGluZ19oaXN0b3J5OiBpdGVtLm1vZGVsX3JvdXRpbmdfaGlzdG9yeT8uUyB8fCAnJyxcbiAgICB1c2VyX2lkOiBpdGVtLnVzZXJfaWQ/LlMgfHwgbnVsbCxcbiAgICBtZXRhZGF0YTogaXRlbS5tZXRhZGF0YT8uUyB8fCBudWxsLFxuICAgIHRocmVhZF9pZDogaXRlbS50aHJlYWRfaWQ/LlMgfHwgbnVsbCxcbiAgICBwcm92aWRlcjogaXRlbS5wcm92aWRlcj8uUyB8fCBudWxsLFxuICAgIG1vZGVsOiBpdGVtLm1vZGVsPy5TIHx8IG51bGwsXG4gICAgY29zdDogY29zdFZhbCxcbiAgICByYXdfcmVxdWVzdDogaXRlbS5yYXdfcmVxdWVzdD8uUyB8fCBudWxsLFxuICAgIHJhd19yZXNwb25zZTogaXRlbS5yYXdfcmVzcG9uc2U/LlMgfHwgbnVsbCxcbiAgICBlcnJvcl9tZXNzYWdlOiBpdGVtLmVycm9yX21lc3NhZ2U/LlMgfHwgbnVsbCxcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXI6IEJhdGNoLWRlbGV0ZSBpdGVtcyBmcm9tIER5bmFtb0RCICgyNSBhdCBhIHRpbWUpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUl0ZW1zRnJvbUREQihkeW5hbW9JdGVtczogYW55W10pIHtcbiAgbGV0IHRvdGFsRGVsZXRlZCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbW9JdGVtcy5sZW5ndGg7IGkgKz0gMjUpIHtcbiAgICBjb25zdCBiYXRjaCA9IGR5bmFtb0l0ZW1zLnNsaWNlKGksIGkgKyAyNSk7XG5cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGBERUJVRzogRGVsZXRpbmcgYmF0Y2ggb2YgJHtiYXRjaC5sZW5ndGh9IGl0ZW1zIGZyb20gaW5kZXggWyR7aX06JHtcbiAgICAgICAgaSArIDI1XG4gICAgICB9XS5gXG4gICAgKTtcblxuICAgIGF3YWl0IGRkYi5zZW5kKFxuICAgICAgbmV3IEJhdGNoV3JpdGVJdGVtQ29tbWFuZCh7XG4gICAgICAgIFJlcXVlc3RJdGVtczoge1xuICAgICAgICAgIFtUQUJMRV9OQU1FXTogYmF0Y2gubWFwKChpdGVtKSA9PiAoe1xuICAgICAgICAgICAgRGVsZXRlUmVxdWVzdDoge1xuICAgICAgICAgICAgICAvLyBUaGUgXCJQS1wiIGFuZCBcIlNLXCIgZmllbGRzIG11c3QgbWF0Y2ggeW91ciB0YWJsZSdzIHJlYWwgcHJpbWFyeSBrZXkgZmllbGRzXG4gICAgICAgICAgICAgIEtleToge1xuICAgICAgICAgICAgICAgIFBLOiBpdGVtLlBLLFxuICAgICAgICAgICAgICAgIFNLOiBpdGVtLlNLLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KSksXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICk7XG4gICAgdG90YWxEZWxldGVkICs9IGJhdGNoLmxlbmd0aDtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKGBERUJVRzogRmluaXNoZWQgZGVsZXRpbmcgJHt0b3RhbERlbGV0ZWR9IGl0ZW1zIHRvdGFsLmApO1xufVxuIl19